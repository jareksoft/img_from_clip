// SPDX-License-Identifier: BSD-2-Clause

#include "clipmonitor.h"
#include <QApplication>
#include <QBuffer>
#include <QDateTime>
#include <QDebug>
#include <QDir>
#include <QFile>
#include <QImage>
#include <QMimeData>
#include <QPainter>
#include <QSvgGenerator>
#include <QTextStream>

ClipMonitor::ClipMonitor(QObject *parent)
    : QObject{parent}
    , m_clipboard(QApplication::clipboard())
{
    m_lastCapture = QDateTime::currentDateTimeUtc();
    connect(m_clipboard, &QClipboard::dataChanged, this, &ClipMonitor::clipboardDataChanged);
    m_lastClipboard = getLastClipboard();

    m_pollTimer = new QTimer(this);
    m_pollTimer->setSingleShot(false);
    m_pollTimer->setInterval(1000);

    connect(m_pollTimer, &QTimer::timeout, this, &ClipMonitor::clipboardDataChanged);

    m_timerBinding = m_activeBinding.addNotifier([&]() {
        if (m_activeBinding.value())
            m_pollTimer->start();
        else
            m_pollTimer->stop();
    });
}

auto ClipMonitor::makeNewSavePath() -> QString
{
    QString pattern = m_savePattern.value();
    if (pattern.isEmpty())
        pattern = QStringLiteral("{timestamp}");

    pattern.replace(QStringLiteral("{timestamp}"),
                    QString::number(QDateTime::currentSecsSinceEpoch()));

    switch (m_saveMode.value()) {
    case SaveMode::SVG:
        pattern.append(QStringLiteral(".svg"));
        break;
    case SaveMode::PNG:
        pattern.append(QStringLiteral(".png"));
        break;
    case SaveMode::JPG:
        pattern.append(QStringLiteral(".jpg"));
        break;
    }

    return pattern;
}

void ClipMonitor::saveRawSvg(const QString &contents)
{
    createSave([&](QIODevice *dev) { dev->write(contents.toUtf8()); });
}

void ClipMonitor::renderSvgToPng(const QString &contents)
{
    QImage image;
    if (image.loadFromData(contents.toUtf8())) {
        savePng(image);
    }
}

void ClipMonitor::renderSvgToJpg(const QString &contents)
{
    QImage image;
    if (image.loadFromData(contents.toUtf8())) {
        saveJpg(image);
    }
}

void ClipMonitor::savePng(const QImage &image)
{
    createSave([&](QIODevice *dev) { image.save(dev, "PNG"); });
}

void ClipMonitor::saveSvg(const QImage &image)
{
    createSave([&](QIODevice *dev) {
        QSvgGenerator generator;
        QRect viewBox;
        viewBox.setSize(image.size());

        generator.setOutputDevice(dev);
        generator.setSize(image.size());
        generator.setViewBox(viewBox);
        generator.setTitle(tr("Generated by QSvgGenerator"));
        generator.setDescription(tr("Image imported from clipboard"));

        QPainter painter;
        painter.begin(&generator);
        painter.drawImage(0, 0, image);
        painter.end();
    });
}

void ClipMonitor::saveJpg(const QImage &image)
{
    createSave([&](QIODevice *dev) { image.save(dev, "JPG"); });
}

void ClipMonitor::createSave(std::function<void(QIODevice *)> callback)
{
    QDir dir(m_savePath.value().toLocalFile());

    if (!dir.exists()) {
        emit saveFailed(tr("Save directory does not exist"));
        return;
    }

    auto path = dir.absoluteFilePath(makeNewSavePath());

    QFile file(path);
    if (!file.open(QIODevice::WriteOnly | QIODevice::NewOnly)) {
        emit saveFailed(file.errorString());
        return;
    }

    qDebug() << "Saving " << file.fileName();

    callback(&file);

    if (file.error()) {
        emit saveFailed(file.errorString());
        file.remove();
    } else {
        emit notifyCapture(path);
    }
}

void ClipMonitor::clipboardDataChanged()
{
    // Ignore if not active
    if (!m_activeBinding.value())
        return;

    auto now = QDateTime::currentDateTimeUtc();

    // Throttle and ignore first signal
    if (m_lastCapture.secsTo(now) < 1) {
        return;
    }
    m_lastCapture = now;

    auto newClip = getLastClipboard();
    if (newClip == m_lastClipboard) {
        return;
    }

    m_lastClipboard = newClip;

    if (std::holds_alternative<QImage>(m_lastClipboard)) {
        switch (m_saveMode) {
        case SaveMode::SVG:
            saveSvg(std::get<QImage>(m_lastClipboard));
            break;
        case SaveMode::PNG:
            savePng(std::get<QImage>(m_lastClipboard));
            break;
        case SaveMode::JPG:
            saveJpg(std::get<QImage>(m_lastClipboard));
            break;
        }
    } else if (std::holds_alternative<QString>(m_lastClipboard)) {
        switch (m_saveMode) {
        case SaveMode::SVG:
            saveRawSvg(std::get<QString>(m_lastClipboard));
            break;
        case SaveMode::PNG:
            renderSvgToPng(std::get<QString>(m_lastClipboard));
            break;
        case SaveMode::JPG:
            renderSvgToJpg(std::get<QString>(m_lastClipboard));
            break;
        }
    }
}

auto ClipMonitor::getLastClipboard() -> std::variant<std::monostate, QImage, QString>
{
    const auto mimeData = m_clipboard->mimeData();

    if (mimeData->hasImage()) {
        return qvariant_cast<QImage>(mimeData->imageData());
    } else if (mimeData->hasText()) {
        return mimeData->text();
    } else {
        return {};
    }
}
