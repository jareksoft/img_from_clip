// SPDX-License-Identifier: BSD-2-Clause

#include "clipmonitor.h"
#include <QApplication>
#include <QBuffer>
#include <QDateTime>
#include <QDebug>
#include <QDir>
#include <QFile>
#include <QImage>
#include <QMimeData>
#include <QPainter>
#include <QRandomGenerator>
#include <QSvgGenerator>
#include <QSysInfo>
#include <QTextDocument>
#include <QTextStream>

ClipMonitor::ClipMonitor(QObject *parent)
    : QObject{parent}, m_clipboard(QApplication::clipboard()) {
  m_lastCapture = QDateTime::currentDateTimeUtc();
  connect(m_clipboard, &QClipboard::dataChanged, this,
          &ClipMonitor::clipboardDataChanged);
  m_lastClipboard = getLastClipboard();

  m_pollTimer = new QTimer(this);
  m_pollTimer->setSingleShot(false);
  m_pollTimer->setInterval(1000);

  connect(m_pollTimer, &QTimer::timeout, this,
          &ClipMonitor::clipboardDataChanged);

  m_timerBinding = m_activeBinding.addNotifier([&]() {
    if (m_activeBinding.value())
      m_pollTimer->start();
    else
      m_pollTimer->stop();
  });

  m_rng.seed(static_cast<uint32_t>(QDateTime::currentMSecsSinceEpoch()));
}

auto ClipMonitor::makeNewSavePath(QString pattern) -> QString {
  if (pattern.isEmpty()) {
    pattern = QStringLiteral("{timestamp}");
  }

  pattern.replace(QStringLiteral("{timestamp}"),
                  QString::number(QDateTime::currentSecsSinceEpoch()));
  pattern.replace(QStringLiteral("{date}"),
                  QDate::currentDate().toString(Qt::DateFormat::ISODate));
  pattern.replace(QStringLiteral("{time}"),
                  QTime::currentTime().toString(Qt::DateFormat::ISODate));
  pattern.replace(QStringLiteral("{cpu}"), QSysInfo::currentCpuArchitecture());
  pattern.replace(QStringLiteral("{hostname}"), QSysInfo::machineHostName());
  pattern.replace(QStringLiteral("{rand}"), QString::number(m_rng()));

  pattern.replace(QChar('/'), QChar('_'));
  pattern.replace(QChar('\\'), QChar('_'));
  pattern.replace(QChar(':'), QChar('_'));
  pattern.replace(QChar(';'), QChar('_'));
  pattern.replace(QStringLiteral(".."), QStringLiteral("_"));

  switch (m_saveMode.value()) {
  case SaveMode::SVG:
    pattern.append(QStringLiteral(".svg"));
    break;
  case SaveMode::PNG:
    pattern.append(QStringLiteral(".png"));
    break;
  case SaveMode::JPG:
    pattern.append(QStringLiteral(".jpg"));
    break;
  }

  return pattern;
}

void ClipMonitor::saveRawSvg(const QString &contents) {
  createSave([&](QIODevice *dev) { dev->write(contents.toUtf8()); });
}

void ClipMonitor::renderSvgToPng(const QString &contents) {
  QImage image;
  if (image.loadFromData(contents.toUtf8())) {
    savePng(image);
  }
}

void ClipMonitor::renderSvgToJpg(const QString &contents) {
  QImage image;
  if (image.loadFromData(contents.toUtf8())) {
    saveJpg(image);
  }
}

void ClipMonitor::savePng(const QImage &image) {
  createSave([&](QIODevice *dev) { image.save(dev, "PNG"); });
}

void ClipMonitor::saveSvg(const QImage &image) {
  createSave([&](QIODevice *dev) {
    QSvgGenerator generator;
    QRect viewBox;
    viewBox.setSize(image.size());

    generator.setOutputDevice(dev);
    generator.setSize(image.size());
    generator.setViewBox(viewBox);
    generator.setTitle(tr("Generated by QSvgGenerator"));
    generator.setDescription(tr("Image imported from clipboard"));

    QPainter painter;
    painter.begin(&generator);
    painter.drawImage(0, 0, image);
    painter.end();
  });
}

void ClipMonitor::saveJpg(const QImage &image) {
  createSave([&](QIODevice *dev) { image.save(dev, "JPG"); });
}

void ClipMonitor::createSave(std::function<void(QIODevice *)> callback) {
  QDir dir(m_savePath.value().toLocalFile());

  if (!dir.exists()) {
    emit saveFailed(tr("Save directory does not exist"));
    return;
  }

  auto path = dir.absoluteFilePath(makeNewSavePath(m_savePattern.value()));

  QFile file(path);
  if (!file.open(QIODevice::WriteOnly | QIODevice::NewOnly)) {
    emit saveFailed(file.errorString());
    return;
  }

  qDebug() << "Saving " << file.fileName();

  callback(&file);

  if (file.error()) {
    emit saveFailed(file.errorString());
    file.remove();
  } else {
    emit notifyCapture(path);
  }
}

void ClipMonitor::clipboardDataChanged() {
  // Ignore if not active
  if (!m_activeBinding.value())
    return;

  auto now = QDateTime::currentDateTimeUtc();

  // Throttle and ignore first signal
  if (m_lastCapture.secsTo(now) < 1) {
    return;
  }
  m_lastCapture = now;

  auto newClip = getLastClipboard();
  if (newClip == m_lastClipboard) {
    return;
  }

  m_lastClipboard = newClip;

  if (std::holds_alternative<QImage>(m_lastClipboard)) {
    qDebug() << "Got image";
    switch (m_saveMode) {
    case SaveMode::SVG:
      saveSvg(std::get<QImage>(m_lastClipboard));
      break;
    case SaveMode::PNG:
      savePng(std::get<QImage>(m_lastClipboard));
      break;
    case SaveMode::JPG:
      saveJpg(std::get<QImage>(m_lastClipboard));
      break;
    }
  } else if (std::holds_alternative<Html>(m_lastClipboard)) {
    qDebug() << "Got HTML";
    if (m_htmlAllowed.value()) {
      QTextDocument doc;
      doc.setTextWidth(m_renderWidth.value());
      doc.setHtml(std::get<Html>(m_lastClipboard).html);

      if (m_saveMode == SaveMode::SVG) {
        createSave([&](QIODevice *dev) {
          QSvgGenerator generator;

          QRect viewBox;
          viewBox.setSize(doc.size().toSize());

          generator.setOutputDevice(dev);
          generator.setSize(viewBox.size());
          generator.setViewBox(viewBox);
          generator.setTitle(tr("Generated by QSvgGenerator"));
          generator.setDescription(tr("HTML imported from clipboard"));

          QPainter painter;
          painter.begin(&generator);
          doc.drawContents(&painter);
          painter.end();
        });
      } else {
        QImage image(doc.size().toSize(), QImage::Format_ARGB32_Premultiplied);
        QPainter painter(&image);
        painter.setRenderHints(QPainter::Antialiasing |
                               QPainter::SmoothPixmapTransform);
        doc.drawContents(&painter);

        switch (m_saveMode) {
        case SaveMode::SVG:
          saveSvg(image);
          break;
        case SaveMode::PNG:
          savePng(image);
          break;
        case SaveMode::JPG:
          saveJpg(image);
          break;
        }
      }
    } else {
      qDebug() << "HTML not allowed";
    }
  } else if (std::holds_alternative<QString>(m_lastClipboard)) {
    qDebug() << "Got string";
    switch (m_saveMode) {
    case SaveMode::SVG:
      saveRawSvg(std::get<QString>(m_lastClipboard));
      break;
    case SaveMode::PNG:
      renderSvgToPng(std::get<QString>(m_lastClipboard));
      break;
    case SaveMode::JPG:
      renderSvgToJpg(std::get<QString>(m_lastClipboard));
      break;
    }
  }
}

auto ClipMonitor::getLastClipboard() -> contents_t {
  const auto mimeData = m_clipboard->mimeData();

  if (mimeData->hasImage()) {
    return qvariant_cast<QImage>(mimeData->imageData());
  } else if (mimeData->hasHtml()) {
    return Html{mimeData->html()};
  } else if (mimeData->hasText()) {
    return mimeData->text();
  } else {
    return {};
  }
}
